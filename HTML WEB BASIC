IP 인터넷 프로토콜 역할 : 지정한 IP주소에 패킷이라는 통신 단위로 데이터 전달
 → 출발지 IP와 목적지 IP를 입력하고 던지면 인터넷 노드에서 최종 목적지 서버까지 도달함.

TCP 프로토콜
 → IP, PORT, 전송 제어, 순서, 검증 정보 등….
 → 연결 지향 - TCP 3 way handshake (가상연결)
 → 순서 보장
 → 데이터 전달 보증
  → 신뢰할 수 있는 프로토콜이며 현재 대부분 TCP 사용

※ TCP 3 way handshake
 1. SYN : 접속 요청
 2. ACK : 요청 수락
 3. 데이터 전송

UDP 프로토콜
 → TCP와 달리 기능이 거의 없음
 → 연결지향 X, 순서 보장 X, 데이터 전달 보증 X
 → 데이터 전달 및 순서가 보장되지 않지만, 단순하고 빠름
 → IP와 거의 같음. +PORT, +체크섬 정도만 추가

PORT
 → 같은 IP 내에서 프로세스 구분
 → 0~1023 : 잘 알려진 포트들이 있으므로 사용하지 않는 것이 좋음
  ※ HTTP : 80 / HTTPS : 443 / FTP : 20, 21 / TELNET-23

DNS (도메인 네임 시스템)
 → IP대신 문자로 된 주소값을 사용이 가능

URI
 → Uniform : 리소스 식별하는 통일된 방식
 → Resource : 자원, URI로 식별할 수 있는 모든 것(제한 없음)
 → Identifier : 다른 항목과 구분하는데 필요한 정보
 → URL : Uniform Resource Locator : 로케이터를 이용하여 식별하는것
 → URN : Name을 이용하여 식별하는것. 현재는 거의 사용을 하지 않음
  → URI는 URL과 URN을 모두 포함하지만 URN은 보편화되지 않아서 URI와 URL을 같은 의미로 사용을 많이 함

HTTP
 → TEXT, 이미지, 음성, 영상 등 거의 모든 형태의 데이터 전송이 가능
 → 서버간에 데이터를 주고 받을 때도 특수한 경우를 제외하고는 대부분 HTTP 사용
  → HTTP/1.1 1997년 : 가장 많이 사용, 현재 웹에서 가장 많이 사용 함
  → HTTP/2 2015년 : 성능 개선 위주
  → HTTP/3 진행 중 : 기존에 많이 사용하던 TCP 대신에 UDP 사용, 성능 개선
  ※ HTTP3에서 UDP를 채택

※ 개발자도구 - 네트워크 - 우클릭해서 프로토콜 추가 : 현재 사용하는 HTTP 프로토콜 확인이 가능하다.

무상태 프로토콜 (Stateless)
 → 서버가 클라이언트 상태를 보존하지 않음
 → 서버 확장성이 높다는 장점이 있으나 클라이언트가 추가 데이터 전송
  → 이전 데이터를 저장하지 않기 때문에 클라이언트가 이전 데이터를 같이 보내야 한다.
  → 병렬처리하여 하나의 클라이언트에 대해서 서버를 여러개 둘 수 있음
  → 한계 : 로그인 한 사용자의 경우 쿠키나 서버 세션등에서 한계점이 발생함

비 연결성
 → 클라이언트의 요청을 받으면 응답을 해주고 바로 연결을 끊어버림
 → HTTP는 기본이 연결을 유지하지 않는 모델
 → 일반적으로 초 단위의 이하의 빠른 속도로 응답
 → 서버 자원을 매우 효율적으로 사용할 수 있음
 → 자바스크립트, CSS 등 수많은 자원이 새로 다운로드 되는 문제가 있어서 HTTP 지속 연결로 문제 해결
 → HTTP/2, HTTP/3에서 더 많은 최적화

스테이트리스 (Stateless)
 → 서버 개발자들이 어려워하는 업무
 → 같은 시간에 딱 맞추어 발생하는 대용량 트래픽
  → 예) 저녁 6:00 선착순 1000명 치킨 할인 이벤트 → 수만명 동시 요청

메시지
 → HTTP 요청 메시지 : GET /search?q=hello
 → HTTP 응답 메시지 : HTTP1.1 200 OK

HTTP 상태 코드
 → 200 : 성공
 → 400 : 클라이언트 요청 오류
 → 500 : 서버 내부 오류

HTTP 헤더 용도
 → HTTP 전송에 필요한 모든 부가 정보

HTTP 메시지 바디 용도
 → 실제 전송할 데이터 / 문서, 이미지, 영상, JSON 등등

API URI 설계
 → 리소스 식별
  ※ 리소스의 의미는 뭘까? 회원을 등록하고 수정하는게 아닌, 회원이라는 개념 자체가 리소스
 → /create-member 같은 형태가 아닌 /member/{id} 형태로 리소스가 기준
  ※ PUT, PATCH 차이 : 같은 update 이지만 PUT은 리소스 전부를 업데이트하고, PATCH는 일부를 업데이트 한다.
API POST : 대상 리소스가 리소스의 고유 한 의미 체계에 따라 요청에 포함 된 표현을 처리하도록 요청(???)
  ※ 리소스 만으로 처리하기 애매한 경우에는 아래와 같이 설계 한다.
   →  예) POST /order/{orderId]/start-delivery (컨트롤 URI)
    → 뒤쪽에 추가적인 동작을 기입

API PUT
 → 리소스를 완전히 대체 (기존에 있던 컬럼값이라도 새로 들어온값이 null이면 null로 대체)
  → 리소스가 없으면 생성하고 있으면 대체한다. (있으면 기존 데이터를 덮어버린다.)
   ※ POST 요청값은 /member/ 형태로 단순 생성이지만 PUT는 /member/100 형태로 클라이언트가 리소스 위치를 안다.

API DELETE
 → 리소스 제거

---

멱등
 → 한 번 호출하든 두 번 호출하든 100번 호출하든 결과가 똑같다.
  → GET : 몇번을 조회 하더라도 같은 결과가 조회 된다.
  → PUT : 결과를 대체 한다. 그래서 여러번 요청해도 최종 결과는 같다.
  → DELETE : 결과를 삭제 한다. 같은 요청을 여러번 해도 삭제된 결과는 똑같다.
  → POST : 멱등이 아니다! 두 번 호출하면 같은 경제가 중복해서 발생할 수 있다.
 → 활용
  → 자동 복구 메커니즘, 서버가 TIMEOUT 등으로 정답 응답을 못주었을 때, 클라이언트가 다시 요청해도 되는가…
 ※ 재요청 중간에 다른 곳에서 리소스를 변경 해버리면?
  → A : 멱등은 외부 요인으로 중간에 리소스가 변경되는 것 까지는 고려하지는 않는다.

캐시가능
 → 실제로는 GET, HEAD 정도만 캐시로 사용
 
HTML Form 데이터 전송
 → Content-Type : application/x-www-form-urlencoded 사용 (전송 데이터를 url encoding 처리)
  → ex) abc김 → abc%EA%B9%80

---

API 설계 (POST 기반) - 대부분 POST 기반을 사용 (컬렉션)
 → 회원 목록 /members → GET
 → 회원 등록 /members → POST
 → 회원 조회 /members/{id} → GET
 → 회원 수정 /members/{id} → PATCH, PUT, POST
 → 회원 삭제 /members/{id} → DELETE

API 설계 (PUT 기반)
 → 파일 목록 /files → GET
 → 파일 조회 /files/{filename} → GET
 → 파일 등록 /files/{filename} → PUT
 → 파일 삭제 /files/{filename} → DELETE
 → 파일 대량 등록 /files → POST

스토어
 → 클라이언트가 관리하는 리소스 저장소로 리소스의 URI를 알고 관리한다.
  → 여기서 스토어는 /files

HTML FORM 사용
 → 회원 목록 /members → GET
 → 회원 등록 폼 /members/new → GET
 → 회원 등록 /members/new, /members → POST (둘 다 가능하지만 /members/new 선호)
 → 회원 조회 /members/{id} → GET
 → 회원 수정 폼 /members/{id}/edit → GET
 → 회원 수정 /members/{id}/edit, /members/{id} → POST
 → 회원 삭제 /members/{id}/delete → POST
  → 컨트롤 URI
   → GET, POST 만 지원하는 제약을 해결 하기 위해 동사로 된 리소스 경로 사용
   → POST의 /new, /edit, /delete가 컨트롤 URI
※ 최대한 리소스 개념을 기준으로 설계를 하고 컨트롤 URI는 대체재로만 사용해야 함

참고하면 좋은 URI 설계 개념
 → 문서 : 단일 개념(파일 하나, 객체  인스턴스)
 → 컬렉션 : 서버가 관리하는 리소스 디렉터리
 → 스토어 : 클라이언트가 관리하는 자원 저장소
 → 컨트롤러, 컨트롤 URI : 문서, 컬렉션, 스토어로 해결하기 어려운 경우 동사를 직접 사용 ( /members/{id}/delete )

상태 코드
 → 2xx : 요청 정상 처리
 → 3xx : 요청을 완료하려면 추가 행동이 필요
 → 4xx : 클라이언트 오류, 잘못된 문법 등으로 서버가 요청을 수행할 수 없음
 → 5xx : 서버 오류, 서버가 정상 요청을 처리하지 못함

일시적인 리다이렉션
 → 리소스의 URI가 일시적으로 변경
  → POST로 주문 후 웹 브라우저를 새로고침하면? 새로고침에 다시 요청되어 중복 주문이 될 수 있다.

PRG(Post/Redirect/Get)
 → POST로 요청했을 때 서버의 응답을 302 Found 리다이렉트 하고 클라이언트에서 GET으로 요청

400 Bad Request
 → 클라이언트가 잘못된 요청을 해서 서버가 요청을 처리할 수 없음
401 Unauthorized
 → 클라이언트가 해당 리소스에 대한 인증이 필요함 (로그인)
403 Forbidden
 → 서버가 요청을 이해했지만 승인을 거부함 (어드민 등급이 아닌 사용자가 접근)
404 Not Found
 → 요청 리소스를 찾을 수 없음
500 Internal Server Error
 → 서버 문제로 오류 발생, 애매하면 다 500 오류
503 Service Unavailable
 → 서비스 이용 불가, 서버가 일시적인 과부하 또는 예정된 작업으로 잠시 요청을 처리할 수 없음

---

HTTP 헤더
 → HTTP 전송에 필요한 모든 부가정보
HTTP 바디 (RFC7230 - 최신)
 → 메시지 본문을 통해 표현 데이터 전달
 → 메시지 본문 = 페이로드 / 표현 = 요청이나 응답에서 전달할 실제 데이터
 
표현
 → Content-Type : 표현 데이터의 형식
  → 예) text/html;   application/json
 → Content-Encoding : 표현 데이터의 압축 방식
  → 예) gzip, delate, identity
 → Content-Language : 표현 데이터의 자연 언어
  → 예) ko, en, en-US
 → Content-Length : 표현 데이터의 길이
 → 표현 헤더는 전송, 응답 둘 다 사용

협상(콘텐츠 네고시에이션) : 클라이언트가 선호하는 표현 요청
 → Accept : 클라이언트가 선호하는 미디어 타입 전달
 → Accept-Charset : 클라이언트가 선호하는 문자 인코딩
 → Accept-Encoding : 클라이언트가 선호하는 압축 인코딩
 → Accept-Language : 클라이언트가 선호하는 자연 언어
 → 협상 헤더는 요청시에만 사용
※ ex) Accept-Language 적용 전에는 응답이 “hello”라면 ko 적용 후에는 “안녕하세요”로 응답을 받음

협상과 우선순위1
 → 우선순위를 지정할 수 있음. 0~1, 클수록 높은 우선 순위. 생략하면 1
 → Accept-Language: ko-KR, ko;q=9, en-US;q=0.8, en;q=0.7
  → 한국어가 없으면 영어로 응답을 받을 수 있음

협상과 우선순위2
 → 구체적인 것이 우선한다.
 → Accept : text/*, text/plain, text/plain;format:flowed
  →  text/plain;format:flowed , text/plain , text/* 순으로 구체적일수록 우선순위가 높다.

협상과 우선순위3
 → 구체적인것을 기준으로 미디어 타입을 맞춘다.

전송 방식
 → 단순 전송
 → 압축 전송 : gzip 압축해서 전송
 → 분할 전송 : chunked 5바이트 먼저 보내고 그 다음에 5바이트 보내는 식으로 분할해서 전송
  ※ Content-Length 보낼 수 없음
 → 범위 전송 : Byte 1001-2000/2000 분할해서 전송함
